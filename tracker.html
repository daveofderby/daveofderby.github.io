<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Live Location Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      #map {
        height: 50vh;
        width: 100%;
      }
      html,
      body {
        margin: 0;
        padding: 0;
      }
    </style>
  </head>
  <body>
    <div id="map"></div>
    <div id="info"></div>
    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <!-- <script src="app.js"></script> -->
  </body>
</html>

<script>
  //test data
  const geoStoryPages = [
    { latitude: 52.8902, longitude: -1.502752, title: "Once upon a time there was a fox" },
    { latitude: 52.890486, longitude: -1.502613, title: "Who was very fond of chilli" },
    { latitude: 52.8902, longitude: -1.502555, title: "but if he couldn't eat chilli, he ate cats!" },
  ];

  // define div sections
  const divInfo = document.querySelector("#info");

  let currentPage = 0;
  let fromLat = 0;
  let fromLon = 0;
  let toLat = 0;
  let toLon = 0;

  // get starting position
  const currentPosition = navigator.geolocation.getCurrentPosition(
    (position) => {
      console.log("Current Position inside: ", position.coords);
      fromLat = position.coords.latitude;
      fromLon = position.coords.longitude;
      return position.coords;
    },
    (error) => {
      const resetButton = document.createElement("btn");

      resetButton.innerHTML = "Retry";
      divInfo.append(resetButton);

      console.error("Error getting location:", error);
      console.log("Error: The Geolocation service failed.");
      return error;
    },
    {
      enableHighAccuracy: true, // Request more accurate location
      timeout: 0, // Wait up to 5 seconds for a result
      maximumAge: 0, // Don't use a cached position if set to 0
    }
  );

  const map = L.map("map", { zoomControl: false, boxZoom: false, zoomSnap: 0, doubleClickZoom: false, minZoom: 15, scrollWheelZoom: true, touchZoom: true }).setView([fromLat, fromLon], 19); // Initial view [latitude, longitude], zoom

  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
    // attribution: 'Map data © <a href="https://openstreetmap.org">OpenStreetMap</a>',
  }).addTo(map);

  const userIcon = L.icon({
    iconUrl: "icon-man.png",
    iconSize: [30, 30],
    iconAnchor: [15, 25],
    zIndexOffset: 1000,
  });

  const toIcon = L.icon({
    iconUrl: "icon-page.png",
    iconSize: [24, 30],
    iconAnchor: [12, 25],
  });

  const foundIcon = L.icon({
    iconUrl: "icon-pin.png",
    iconSize: [30, 30],
    iconAnchor: [15, 25],
  });

  const userMarker = L.marker([0, 0], { riseOnHover: true, opacity: 1, icon: userIcon }).addTo(map);
  toLat = geoStoryPages[currentPage].latitude;
  toLon = geoStoryPages[currentPage].longitude;
  destinationMarker = L.marker([toLat, toLon], { riseOnHover: true, opacity: 1, icon: toIcon }).addTo(map);

  if (navigator.geolocation) {
    navigator.geolocation.watchPosition(
      (position) => {
        const { fromLat: latitude, fromLon: longitude } = position.coords;
        const newLatLng = new L.LatLng(fromLat, fromLon);
        console.log("Current Position Watch:", newLatLng);
        map.setView([fromLat, fromLon]);

        // Update the marker's position
        userMarker.setLatLng(newLatLng);

        // Center the map on the new position
        map.panTo(newLatLng);

        const distance = calculateDistance(fromLat, fromLon, toLat, toLon);
        const bearing = calculateBearing(fromLat, fromLon, toLat, toLon);

        showInfo(fromLat, fromLon, toLat, toLon, distance, bearing);

        if (distance < 5) {
          currentPage++;
          if (currentPage < geoStoryPages.length) {
            toLat = geoStoryPages[currentPage].latitude;
            toLon = geoStoryPages[currentPage].longitude;
            destinationMarker.remove(map);
            destinationMarker = L.marker([toLat, toLon], { riseOnHover: true, opacity: 1, icon: toIcon }).addTo(map);
          }
        }
      },
      (error) => {
        console.error("Error getting location:", error);
        console.log("Error: The Geolocation service failed.");
      },
      {
        enableHighAccuracy: true, // Request more accurate location
        timeout: 1000, // Wait up to 5 seconds for a result
        maximumAge: 3000, // Don't use a cached position if set to 0
      }
    );
  } else {
    alert("Geolocation is not supported by your browser.");
  }

  function showInfo(fromLat, fromLon, toLat, toLon, distance, bearing) {
    console.log(`Distance: ${distance.toFixed(0)} m`); // Distance in meters
    console.log(`Initial Bearing: ${bearing.toFixed(0)}°`); // Initial bearing in degrees

    const info = document.querySelector("#info");
    info.innerHTML = `<p>From: ${fromLat} / ${fromLon}</p><p>To: ${toLat} / ${toLon}</p><p>Distance: ${distance.toFixed(0)} m</p><p>Initial Bearing: ${bearing.toFixed(0)}°</p><p>Found Target: ${distance < 5 ? "True" : "False"}</p><p>Current Page: ${currentPage + 1}</p><p>Current Page: ${geoStoryPages[currentPage].title}</p>`;
  }

  function degreesToRadians(degrees) {
    return degrees * (Math.PI / 180);
  }

  function calculateDistance(fromLat, fromLon, toLat, toLon) {
    const R = 6371; // Earth's radius in kilometers
    const rlat1 = degreesToRadians(fromLat);
    const rlat2 = degreesToRadians(toLat);
    const difflat = rlat2 - rlat1;
    const difflon = degreesToRadians(toLon) - degreesToRadians(fromLon);

    const d = 2 * R * Math.asin(Math.sqrt(Math.sin(difflat / 2) * Math.sin(difflat / 2) + Math.cos(rlat1) * Math.cos(rlat2) * Math.sin(difflon / 2) * Math.sin(difflon / 2)));
    return d * 1000; // in metres
  }

  function calculateBearing(fromLat, fromLon, toLat, toLon) {
    const rlat1 = degreesToRadians(fromLat);
    const rlat2 = degreesToRadians(toLat);
    const difflon = degreesToRadians(toLon) - degreesToRadians(fromLon);

    const y = Math.sin(difflon) * Math.cos(rlat2);
    const x = Math.cos(rlat1) * Math.sin(rlat2) - Math.sin(rlat1) * Math.cos(rlat2) * Math.cos(difflon);
    const brng = Math.atan2(y, x); // in radians

    // Convert radians to degrees and normalize to 0-360
    return (brng * (180 / Math.PI) + 360) % 360;
  }
</script>
